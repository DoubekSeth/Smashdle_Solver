---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code.

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*.

```{r}
# Data Sheet
library(readr)
library(igraph)
smashdle_csv <- read_csv("Smashdle_CSV.csv")
View(smashdle_csv)
```

```{r}
# States that each category can take
gender_states = c("Incorrect", "Correct")
species_states = c("Incorrect", "Partial", "Correct")
universe_states = c("Incorrect", "Partial", "Correct")
weight_states = c("Lower", "Higher", "Correct") #Note: whether the target is higher or lower than the guess
first.appearance_states = c("Incorrect", "Correct")
platform.of.origin_states = c("Incorrect", "Partial", "Correct")
origin.date_states = c("Lower", "Higher", "Correct")

# Generating all possible state combinations
possible_states = list(gender_states, species_states, universe_states, weight_states, first.appearance_states, platform.of.origin_states, origin.date_states)
names(possible_states) = c("Gender", "Species", "Universe", "Weight", "First.Appearance", "Platform.of.Origin", "Origin.Date")
possible_state_combos = expand.grid(possible_states)
possible_state_combos
```

The Blocks below are useful for determining which starting character is the best

```{r}
# Checks if a character matches a given state pattern, returns true if match else false
check_state = function(g, smasher, state, characters){
  for(i in 1:ncol(state)){
    category_name = colnames(state[i])[1]
    g_cat_val = characters[characters$Character == g, names(characters) == category_name][[1]]
    smasher_cat_val = characters[characters$Character == smasher, names(characters) == category_name][[1]]
    #print(category_name)
    #print(g_cat_val)
    #print(smasher_cat_val)
    
    # Now, let's go by the different options that states can be
    if(state[i] == "Incorrect"){
      # Splitting the string in a vector
      g_part_vec = strsplit(g_cat_val, ",\\s*")[[1]]
      smasher_part_vec = strsplit(smasher_cat_val, ",\\s*")[[1]]
      
      #Checking if any part of the first vector shows up in the second
      if(any(g_part_vec %in% smasher_part_vec)){
        return(FALSE)
      }
    } else if(state[i] == "Correct"){
      if(g_cat_val != smasher_cat_val){
        return(FALSE)
      }
    } else if(state[i] == "Partial"){
      # Splitting the string in a vector
      g_part_vec = strsplit(g_cat_val, ",\\s*")[[1]]
      smasher_part_vec = strsplit(smasher_cat_val, ",\\s*")[[1]]
      
      #Checking if any part of the first vector shows up in the second but they aren't the same
      if(!any(g_part_vec %in% smasher_part_vec) || g_cat_val == smasher_cat_val){
        return(FALSE)
      }
    } else if(state[i] == "Lower"){
      if(smasher_cat_val >= g_cat_val){
        return(FALSE)
      }
    } else if(state[i] == "Higher"){
      if(smasher_cat_val <= g_cat_val){
        return(FALSE)
      }
    } else {
      print("Problem in state")
      return(FALSE)
    }
  }
  return(TRUE)
}

# Let's make a function that gets the entropy of a guess, where x is the different states a guess can take and g is a guess. Now returns states and their corresponding possible remaining rosters
# E[g] = sum_x p(x) * -log_2(p(x))
entropy = function(g, possible_state_combos, characters){
  # returned at end to find entropy
  entropy = 0
  state_list = list()
  roster_list = list()
  for(i in 1:nrow(possible_state_combos)){
    state = possible_state_combos[i, ]
    
    # Next, count how many characters match the state pattern
    sum = 0
    state_char_list = list()
    for(charac_i in 1:nrow(characters)){
       charac = characters[charac_i, names(characters) == "Character"][[1]]
       if(check_state(g, charac, state, characters)){
         state_char_list[length(state_char_list)+1] = list(charac[[1]])
         sum = sum + 1
      }
    }
    
    #If the sum > 0, then print for debugging
    
    if(sum > 0){
      print(summary(state))
      print(state_char_list)
      #print(sum)
      state_list = append(state_list, list(state))
      roster_list[[length(roster_list)+1]] = state_char_list
      entropy = entropy - (sum/nrow(characters) * log2(sum/nrow(characters)))
    }
    
  }
  return(list(entropy, state_list, roster_list))
}

# loop over the list to find the best smasher
best_char = function(possible_state_combos, full_char_list){
  best_char = ""
  best_entropy = 0
  for(i in 1:nrow(full_char_list)){
    charac = full_char_list[i, names(full_char_list) == "Character"][[1]]
    entropy_of_charac = entropy(charac, possible_state_combos, full_char_list)[[1]]
    
    print(cat("Character: ", charac, ", Entropy: ", entropy_of_charac))
    
    if(entropy_of_charac > best_entropy){
      best_char = charac
      best_entropy = entropy_of_charac
      print("New Best!")
    }
  }
  
  return(best_char)
}
```

While getting the optimal first guess is cool, let's also make it solve the entire thing. Not this isn't an automatic process, you have to feed it the information that the smashdle spits back at you.

```{r}
#The goal of this function is to reduce the roster down to only the eligible candidates given a guess and the state after the guess, returns a trimmed roster
reduce_state_with_prev_guess = function(prev_guess, state, roster){
  remaining_roster = roster[0, ]
  
  #Loop over roster and only collect matches
  for(i in 1:nrow(roster)){
    char_name = roster[i, names(roster) == "Character"][1]
    if(check_state(prev_guess, char_name, state, roster)){
      print(char_name)
      remaining_roster = rbind(remaining_roster, roster[i, ])
    }
  }
  
  return(remaining_roster)
}

#Returns a state given a seven dimensional vector, should be easily typable human input
get_state = function(Gender, Species, Universe, Weight, First.Appearance, Platform.of.Origin, Origin.Date){
  new_state = as.data.frame(list(Gender, Species, Universe, Weight, First.Appearance, Platform.of.Origin, Origin.Date))
  names(new_state) = c("Gender", "Species", "Universe", "Weight", "First.Appearance", "Platform.of.Origin", "Origin.Date")
  return(new_state)
}
```

Now, let's create a flowchart that I can just look at to determine who is the best

```{r}
#Note: I'm setting this field manually because the initial scan takes a long time, this could be coded to manually search for the best character each time but I don't think that's worth it
starting_char = "Dr. Mario"
first_guess_combos = entropy("Dr. Mario", possible_state_combos, smashdle_csv)
```
```{r}
#Setup the chart
starting_vertices_count = length(first_guess_combos[[3]]) + 1
flowchart = make_empty_graph()
flowchart = add_vertices(flowchart, starting_vertices_count)
flowchart = add_edges(flowchart, as.vector(rbind(1, 2:starting_vertices_count)))

#Add attributes, set first one manually
V(flowchart)$roster[[1]] = as.list(smashdle_csv$Character)
for (i in 2:starting_vertices_count){
 V(flowchart)$roster[[i]] = first_guess_combos[[3]][[i-1]]
}
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
