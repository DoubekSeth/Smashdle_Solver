---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code.

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*.

```{r}
# Data Sheet
library(readr)
library(igraph)
library(ggraph)
library(tidygraph)
smashdle_csv <- read_csv("Smashdle_CSV.csv")
View(smashdle_csv)
```

```{r}
# States that each category can take
gender_states = c("Incorrect", "Correct")
species_states = c("Incorrect", "Partial", "Correct")
universe_states = c("Incorrect", "Partial", "Correct")
weight_states = c("Lower", "Higher", "Correct") #Note: whether the target is higher or lower than the guess
first.appearance_states = c("Incorrect", "Correct")
platform.of.origin_states = c("Incorrect", "Partial", "Correct")
origin.date_states = c("Lower", "Higher", "Correct")

# Generating all possible state combinations
possible_states = list(gender_states, species_states, universe_states, weight_states, first.appearance_states, platform.of.origin_states, origin.date_states)
names(possible_states) = c("Gender", "Species", "Universe", "Weight", "First.Appearance", "Platform.of.Origin", "Origin.Date")
possible_state_combos = expand.grid(possible_states)
possible_state_combos
```

The Blocks below are useful for determining which starting character is the best

```{r}
# Checks if a character matches a given state pattern, returns true if match else false
check_state = function(g, smasher, state, characters){
  for(i in 1:ncol(state)){
    category_name = colnames(state[i])[1]
    g_cat_val = characters[characters$Character == g, names(characters) == category_name][[1]]
    smasher_cat_val = characters[characters$Character == smasher, names(characters) == category_name][[1]]
    #print(category_name)
    #print(g_cat_val)
    #print(smasher_cat_val)
    
    # Now, let's go by the different options that states can be
    if(state[i] == "Incorrect"){
      # Splitting the string in a vector
      g_part_vec = strsplit(g_cat_val, ",\\s*")[[1]]
      smasher_part_vec = strsplit(smasher_cat_val, ",\\s*")[[1]]
      
      #Checking if any part of the first vector shows up in the second
      if(any(g_part_vec %in% smasher_part_vec)){
        return(FALSE)
      }
    } else if(state[i] == "Correct"){
      if(g_cat_val != smasher_cat_val){
        return(FALSE)
      }
    } else if(state[i] == "Partial"){
      # Splitting the string in a vector
      g_part_vec = strsplit(g_cat_val, ",\\s*")[[1]]
      smasher_part_vec = strsplit(smasher_cat_val, ",\\s*")[[1]]
      
      #Checking if any part of the first vector shows up in the second but they aren't the same
      if(!any(g_part_vec %in% smasher_part_vec) || g_cat_val == smasher_cat_val){
        return(FALSE)
      }
    } else if(state[i] == "Lower"){
      if(smasher_cat_val >= g_cat_val){
        return(FALSE)
      }
    } else if(state[i] == "Higher"){
      if(smasher_cat_val <= g_cat_val){
        return(FALSE)
      }
    } else {
      print("Problem in state")
      return(FALSE)
    }
  }
  return(TRUE)
}

# Let's make a function that gets the entropy of a guess, where x is the different states a guess can take and g is a guess. Now returns states and their corresponding possible remaining rosters
# E[g] = sum_x p(x) * -log_2(p(x))
entropy = function(g, possible_state_combos, characters){
  # returned at end to find entropy
  entropy = 0
  state_list = list()
  roster_list = list()
  for(i in 1:nrow(possible_state_combos)){
    state = possible_state_combos[i, ]
    
    # Next, count how many characters match the state pattern
    sum = 0
    state_char_list = list()
    for(charac_i in 1:nrow(characters)){
       charac = characters[charac_i, names(characters) == "Character"][[1]]
       if(check_state(g, charac, state, characters)){
         state_char_list[length(state_char_list)+1] = list(charac[[1]])
         sum = sum + 1
      }
    }
    
    #If the sum > 0, then print for debugging
    
    if(sum > 0){
      #print(summary(state))
      #print(state_char_list)
      #print(sum)
      state_list = append(state_list, list(state))
      roster_list[[length(roster_list)+1]] = state_char_list
      entropy = entropy - (sum/nrow(characters) * log2(sum/nrow(characters)))
    }
    
  }
  return(list(entropy, state_list, roster_list))
}

# loop over the list to find the best smasher
best_char = function(possible_state_combos, full_char_list){
  best_char = ""
  best_entropy = 0
  for(i in 1:nrow(full_char_list)){
    charac = full_char_list[i, names(full_char_list) == "Character"][[1]]
    entropy_of_charac = entropy(charac, possible_state_combos, full_char_list)[[1]]
    
    print(cat("Character: ", charac, ", Entropy: ", entropy_of_charac))
    
    if(entropy_of_charac > best_entropy){
      best_char = charac
      best_entropy = entropy_of_charac
      print("New Best!")
    }
  }
  
  return(best_char)
}
```

While getting the optimal first guess is cool, let's also make it solve the entire thing. Not this isn't an automatic process, you have to feed it the information that the smashdle spits back at you.

```{r}
#The goal of this function is to reduce the roster down to only the eligible candidates given a guess and the state after the guess, returns a trimmed roster
reduce_state_with_prev_guess = function(prev_guess, state, roster){
  remaining_roster = roster[0, ]
  
  #Loop over roster and only collect matches
  for(i in 1:nrow(roster)){
    char_name = roster[i, names(roster) == "Character"][1]
    if(check_state(prev_guess, char_name, state, roster)){
      print(char_name)
      remaining_roster = rbind(remaining_roster, roster[i, ])
    }
  }
  
  return(remaining_roster)
}

#Returns a state given a seven dimensional vector, should be easily typable human input
get_state = function(Gender, Species, Universe, Weight, First.Appearance, Platform.of.Origin, Origin.Date){
  new_state = as.data.frame(list(Gender, Species, Universe, Weight, First.Appearance, Platform.of.Origin, Origin.Date))
  names(new_state) = c("Gender", "Species", "Universe", "Weight", "First.Appearance", "Platform.of.Origin", "Origin.Date")
  return(new_state)
}
```

Now, let's create a flowchart that I can just look at to determine who is the best. Note: We actually only need to call this function once due to how the smashdle works. That means that at most you should only need 3 guesses to get optimal. If it had to be further expanded then you could run this on a while loop seeing if the expanded nodes have the same number as the original nodes.

```{r}
# Expands the non-leaf nodes of the graph to create the flowchart
expand_children = function(graph){
  for(i in V(graph)){
    #If it's both currently a leaf node and has multiple people in the roster, expand it
    if(degree(graph, V(graph)[i]) <= 1 && length(V(graph)[[i]]$roster) > 1){
      next_state_roster_combos = entropy(V(graph)[[i]]$label, possible_state_combos, smashdle_csv[smashdle_csv$Character %in% V(graph)[[i]]$roster, ])
      next_state_roster_entropy = next_state_roster_combos[[1]]
      next_state_roster_states = next_state_roster_combos[[2]]
      next_state_roster_rosters = next_state_roster_combos[[3]]
      
      #Add new vertices
      old_vertex_count = length(V(graph))
      num_new_vertices = length(next_state_roster_rosters)
      new_vertex_count = old_vertex_count + num_new_vertices
      graph = add_vertices(graph, num_new_vertices)
      #Add information to the new vertices
      j = 1
      for(k in (old_vertex_count+1):new_vertex_count){
        #Add new roster
        print(next_state_roster_rosters[[j]])
        V(graph)[[k]]$roster = next_state_roster_rosters[[j]]
        print(V(graph)[[k]]$roster)
        # Add new label (best guess)
        # Now, find the best character
        remaining_roster = V(graph)[[k]]$roster
        if(length(remaining_roster) == 1){
          V(graph)$label[[k]] = remaining_roster[1]
        } else {
          remaining_roster_df = smashdle_csv[smashdle_csv$Character %in% remaining_roster, ]
          best_char_name = best_char(possible_state_combos, remaining_roster_df)
          V(graph)$label[[k]] = best_char_name
          print(best_char_name)
          print(remaining_roster)
        }
        #Add new edge
        new_edge = c(i, k)
        graph = add_edges(graph, new_edge)
        
        #Add state info to edge
        newest_edge = length(E(graph))
        E(graph)$state[[newest_edge]] = next_state_roster_states[[j]]
        E(graph)$label[[newest_edge]] = paste(next_state_roster_states[[j]], collapse = ", ")
        
        #iterate through roster
        j = j+1
      }
      
      
      #Todo
      #Add information to the new edges
      #print(next_state_roster_combos[[1]])
      #print(next_state_roster_combos[[2]])
      #print(next_state_roster_combos[[3]])
    }
  }
  return(graph)
}
```

```{r}
#Note: I'm setting this field manually because the initial scan takes a long time, this could be coded to manually search for the best character each time but I don't think that's worth it
starting_char = "Dr. Mario"
first_guess_combos = entropy("Dr. Mario", possible_state_combos, smashdle_csv)
```


```{r}
#Setup the chart
starting_vertices_count = 1 #length(first_guess_combos[[3]]) + 1
flowchart = make_empty_graph()
flowchart = add_vertices(flowchart, starting_vertices_count)
#flowchart = add_edges(flowchart, as.vector(rbind(1, 2:starting_vertices_count)))

#Add attributes, set first one manually
#Adding the roster to the vertices
V(flowchart)$roster[[1]] = as.list(smashdle_csv$Character)

#Add labels to the vertices, these are the characters you should guess
V(flowchart)$label[[1]] = "Dr. Mario"

#Manually doing 2 cycles since I know that's how many this one needs, theoretically could call this more times and do automatically
expanded_flowchart = expand_children(flowchart)
expanded_2_flowchart = expand_children(expanded_flowchart)


plot(expanded_2_flowchart, vertex.size = 10)
```
That plot sucks, let's try another one
```{r}
#Trying to make the graph more readable
two_select_map = c("1" = "游린", "2" = "游릴")
three_select_map = c("1" = "游린", "2" = "游릳", "3" = "游릴")
up_down_map = c("1" = "拘勇", "2" = "拘勇", "3" = "游릴")
maps = list(two_select_map, three_select_map, three_select_map, up_down_map, two_select_map, three_select_map, up_down_map)
emoji_labels = lapply(E(expanded_2_flowchart)$label, function(x) mapply(function(v, map) map[[v]], as.numeric(unlist(strsplit(x, ",\\s*"))), maps))

ggraph(expanded_2_flowchart, layout = 'unrooted') + geom_edge_link(aes(label = emoji_labels)) + geom_node_label(aes(label = label))
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
